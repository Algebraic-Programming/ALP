
/*
 *   Copyright 2021 Huawei Technologies Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file
 *
 * Provides CodeGen for the Ascend backend.
 *
 * @author A. N. Yzelman
 * @date 12th of September, 2023
 */

#include <graphblas/ascend/opgen.hpp>
#include <graphblas/ascend/symbolTable.hpp>

namespace alp
{
	namespace internal
	{
		extern SymbolTable symbols;
	}
}

std::string alp::internal::OpGen::kernel_id;

size_t alp::internal::OpGen::forEachLevel = 0;

std::vector< std::vector< int > > alp::internal::OpGen::forEachAxes;
std::vector< int > alp::internal::OpGen::lastAxes;

//TODO how is this supposed to be used?
//std::map< std::string, std::string > alp::internal::OpGen::chunkSize;

std::stringstream alp::internal::OpGen::aux_func;
std::stringstream alp::internal::OpGen::analyticModelFormalParams;
std::stringstream alp::internal::OpGen::hostFormalParam;
std::stringstream alp::internal::OpGen::hostArg;
std::stringstream alp::internal::OpGen::constrBody;
std::stringstream alp::internal::OpGen::hostBody;
std::stringstream alp::internal::OpGen::classMembers;
std::stringstream alp::internal::OpGen::initBody;
std::stringstream alp::internal::OpGen::genericProcessBody;
std::stringstream alp::internal::OpGen::declarations;

std::vector< std::stringstream > alp::internal::OpGen::processFunc;
std::vector< std::stringstream > alp::internal::OpGen::computeFunc;
std::vector< std::stringstream > alp::internal::OpGen::copyinFunc;
std::vector< std::stringstream > alp::internal::OpGen::copyoutFunc;

void alp::internal::OpGen::compileClear() {

//	chunkSize.clear(); //TODO how is this supposed to be used?

	forEachAxes.clear();

	alp::internal::symbols.clearAll();

	aux_func.clear();
	analyticModelFormalParams.clear();
	hostFormalParam.clear();
	hostArg.clear();
	constrBody.clear();
	classMembers.clear();
	initBody.clear();
	genericProcessBody.clear();
	declarations.clear();

	processFunc.clear();
	computeFunc.clear();
	copyinFunc.clear();
	copyoutFunc.clear();
}

// TODOs:
//
//  1. rely on lazy evaluation (le)'s pipelines instead of our own input, output and stages info
//  2. use streams (such as the above initStreams) to generate the content of each component separately.
//      - for example, the parameters to the init function could be gathered in initStream; etc.
//  3. instead of generating the copyIn, copyOut, and compute of the add operation directly, rely on a
//     library of AscendC kernels
//      - for example, we should generate in the case of a fused sequence of operators OP1 and OP2:
//        __aicore__ inline void CopyIn( int32_t progress ) {
//              OP1::CopyIn( progress, ... );
//              OP2::CopyIn( progress, ... );
//              // and so on for further fused ops
//        }
//  4. Instead of hardcoding half as the data type, we should generate it appropriately from the typename T
void alp::internal::OpGen::generate( std::ostream &os ) {
	os << "\n// start automatic ALP/Ascend opgen\n\n";

	os << "#include <kernel_operator.h>\n\n";
	os << "#include \"ascendlib.hpp\"\n\n";
	os << "using namespace AscendC;\n\n";

	// TODO this should be generated by the grid.forEach
	// TODO should we support both following modes?
	//  mode 1: symbolic, the below are parameters to the call to custom_kernels, cannot be constexpr(!)
	//  mode 2: the user passes explicit parameters into alp::Grid, then instead of symbolic output, actual values are emitted as in below
	os << "constexpr int32_t BUFFER_NUM = 1; \n"; // TODO TBC indicates local buffer space in a pipe?
	os << "\n";

	os << aux_func.str();
	os << "\n";

	std::stringstream initFormalParam;
	std::stringstream customFormalParam;
	std::stringstream allAccessedArg;
	std::stringstream allTempLocalDecl;

	alp::internal::symbols.generateGlobalSymbols( initFormalParam, customFormalParam, allAccessedArg, allTempLocalDecl );

	// generate class header
	os << "class " << kernel_id << " {\n\n";
	os << "\tpublic:\n\n";

	// generate class constructor
	os << "\t\t__aicore__ inline " << kernel_id << "( ";
	os << hostFormalParam.str();
	os << analyticModelFormalParams.str();
	os << " ) {\n";
	os << constrBody.str();
	os << "\t\t}\n\n\n";

	// generate init function
	os << "\t\t__aicore__ inline void Init( ";
	os << initFormalParam.str();
	os << " ) {\n";
	os << initBody.str();
	os << "\t\t}\n\n";

	// insert the Process functions
	for( auto it = processFunc.cbegin(); it != processFunc.cend(); ++it ) {
		os << it->str();
		os << "\n\n";
	}

	// generate the generic Process functions
	os << "\t\t__aicore__ inline void Process() {\n";
	os << "\n";
	os << genericProcessBody.str();
	os << "\t\t}\n\n\n";

	// declare private fields
	os << "\tprivate:\n\n";
	os << classMembers.str();
//	os << "\n";
	os << "\t\tTPipe pipe;\n";
	os << "\n";
	os << declarations.str();
	os << allTempLocalDecl.str();
	// end of class
	os << "};\n\n";

	// generate entry function
	os << "extern \"C\" __global__ __aicore__ void custom_" << kernel_id << "(\n\t";
	//print the list of all input and output vectors for the arguments list
	os << initFormalParam.str();
	os << ",\n\t";
	os << hostFormalParam.str();
	os << analyticModelFormalParams.str();
	os << "\n) {\n";
	os << "\t" << kernel_id << " op( ";
	os << hostArg.str();
	os << " );\n";
	os << "\top.Init( ";
	os << allAccessedArg.str();
	os << " );\n";
	os << "\top.Process();\n";
	os << "}\n\n";

	// TODO do we absolutely need to generate the host entry point here?
	os << "#ifndef __CCE_KT_TEST__\n";
	os << "void custom_" << kernel_id << "_do(\n"
		<< "\tuint32_t blockDim,\n"
		<< "\tvoid *l2ctrl,\n"
		<< "\tvoid *stream,\n\t";
	os << customFormalParam.str();
	os << ",\n\t";
	os << hostFormalParam.str();
	os << analyticModelFormalParams.str();
	os << "\n) {\n";

	// generate analytic model
//	os << hostBody.str();

	// generate entry point
	os << "\tcustom_" << kernel_id << "<<< blockDim, l2ctrl, stream >>>( ";
	os << allAccessedArg.str();
	os << ", ";
	os << hostArg.str();
	os << " );\n";
	os << "}\n";
	os << "#endif\n\n";

	os << "// end automatic ALP/Ascend opgen\n\n";
}

