
/*
 *   Copyright 2021 Huawei Technologies Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file ndim_matrix_builders.hpp
 * @author Alberto Scolari (alberto.scolari@huawei.com)
 * @brief Utilities to build matrices for an HPCG simulation in a generic number of dimensions
 *
 * In particular, the main matrices are:
 * - a system matrix, generated from an N-dimenional space of coordinates by iterating along
 *   each dimension in priority order, where the first dimension has highest priority and the last
 *   dimension least priority; for each point (row), all its N-dimensional neighbours within
 *   a given distance are generated for the column
 * - a coarsening matrix, generated by iterating on a coarser system of N dimensions (row) and projecting
 *   each point to a corresponding system of finer sizes
 *
 * @date 2021-04-30
 */

#ifndef _H_GRB_ALGORITHMS_NDIM_MATRIX_BUILDERS
#define _H_GRB_ALGORITHMS_NDIM_MATRIX_BUILDERS

#include <algorithm>
#include <array>
#include <cstddef>
#include <initializer_list>
#include <numeric>
#include <stdexcept>
#include <string>
#include <type_traits>
#include <utility>
#include <vector>
#include <cstddef>
#include <iterator>

#include <graphblas/utils/geometry/linearized_halo_ndim_system.hpp>

#include <graphblas/utils/geometry/linearized_ndim_system.hpp>
#include <graphblas/utils/geometry/linearized_ndim_iterator.hpp>
#include <graphblas/utils/geometry/array_vector_storage.hpp>



namespace grb {

	namespace algorithms {

		template<
			size_t DIMS,
			typename CoordT,
			typename T
		>
		class hpcg_builder;

		template<
			size_t DIMS,
			typename CoordT,
			typename T
		>
		struct matrix_generator_iterator {

			using RowIndexType = CoordT; ///< numeric type of rows
			using ColumnIndexType = CoordT;
			using ValueType = T;
			friend hpcg_builder< DIMS, CoordT, T >;

			using linear_system_t = grb::utils::geometry::linearized_halo_ndim_system< RowIndexType, DIMS >;
			using __iter_t = typename linear_system_t::iterator;
			using self_t = matrix_generator_iterator< DIMS, CoordT, T >;

			struct __value {

				friend self_t;

				__value(
					ValueType diag,
					ValueType non_diag,
					RowIndexType i,
					ColumnIndexType j
				) noexcept :
					diagonal_value( diag ),
					non_diagonal_value( non_diag ),
					_i( i ),
					_j( j )
				{}

				__value( const __value & ) = default;

				__value & operator=( const __value & ) = default;

				inline RowIndexType i() const { return _i; }
				inline ColumnIndexType j() const { return _j; }
				inline ValueType v() const {
					return j() == i() ? diagonal_value : non_diagonal_value;
				}

			private:
				ValueType diagonal_value;     ///< value to be emitted when the object has moved to the diagonal
				ValueType non_diagonal_value; ///< value to emit outside of the diagonal
				RowIndexType _i;
				ColumnIndexType _j;
			};

			// interface for std::random_access_iterator
			using iterator_category = std::random_access_iterator_tag;
			using value_type = __value;
			using pointer = value_type;
			using reference = value_type;
			using difference_type = typename __iter_t::difference_type;

			matrix_generator_iterator( const self_t & ) = default;

			matrix_generator_iterator( self_t && ) = default;

			self_t & operator=( const self_t & ) = default;

			self_t & operator=( self_t && ) = default;

			/**
			 * @brief Increments the iterator by moving coordinates to the next (row, column) to iterate on.
			 *
			 * This operator internally increments the columns coordinates until wrap-around, when it increments
			 * the row coordinates and resets the column coordinates to the first possible columns; this column coordinate
			 * depends on the row coordinates according to the dimensions iteration order and on the parameter \p halo.
			 *
			 * @return matrix_generator_iterator<DIMS, T>& \c this object, with the updated state
			 */
			self_t & operator++() noexcept {
				(void) ++_sys_iter;
				update_coords();
				return *this;
			}

			self_t & operator+=( size_t offset ) {
				_sys_iter += offset;
				update_coords();
				return *this;
			}

			difference_type operator-( const self_t &other ) const {
				return this->_sys_iter - other._sys_iter;
			}

			/**
			 * @brief Operator to compare \c this against \p o  and return whether they differ.
			 *
			 * @param o object to compare \c this against
			 * @return true of the row or the column is different between \p o and \c this
			 * @return false if both row and column of \p o and \c this are equal
			 */
			bool operator!=( const self_t &o ) const {
				return this->_sys_iter != o._sys_iter;
			}

			/**
			 * @brief Operator to compare \c this against \p o  and return whether they are equal.
			 *
			 * @param o object to compare \c this against
			 * @return true of the row or the column is different between \p o and \c this
			 * @return false if both row and column of \p o and \c this are equal
			 */
			bool operator==( const self_t &o ) const {
				return ! operator!=( o );
			}

			/**
			 * @brief Operator returning the triple to directly access row, column and element values.
			 *
			 * Useful when building the matrix by copying the triple of coordinates and value,
			 * like for the BSP1D backend.
			 */
			reference operator*() const {
				return _val;
			}

			pointer operator->() const {
				return &_val;
			}

			/**
			 * @brief Returns current row.
			 */
			inline RowIndexType i() const {
				return _val.i();
			}

			/**
			 * @brief Returns current column.
			 */
			inline ColumnIndexType j() const {
				return _val.j();
			}

			/**
			 * @brief Returns the current matrix value.
			 *
			 * @return ValueType #diagonal_value if \code row == column \endcode (i.e. if \code this-> \endcode
			 * #i() \code == \endcode \code this-> \endcode #j()), #non_diagonal_value otherwise
			 */
			inline ValueType v() const {
				return _val.v();
			}

		private:
			value_type _val;
			const linear_system_t *_lin_system;
			__iter_t _sys_iter;

			/**
			 * @brief Construct a new \c matrix_generator_iterator object, setting the current row as \p row
			 * and emitting \p diag if the iterator has moved on the diagonal, \p non_diag otherwise.
			 *
			 * @param sizes array with the sizes along the dimensions
			 * @param _halo halo of points to iterate around; must be > 0
			 * @param diag value to emit when on the diagonal
			 * @param non_diag value to emit outside the diagonal
			 */
			matrix_generator_iterator(
				const linear_system_t &system,
				ValueType diag,
				ValueType non_diag
			) noexcept :
				_val( diag, non_diag, 0, 0 ),
				_lin_system( &system ),
				_sys_iter( system.begin() )
			{
				update_coords();
			}

			void update_coords() {
				_val._i = _sys_iter->get_element_linear();
				_val._j = _sys_iter->get_neighbor_linear();
			}
		};


		template<
			size_t DIMS,
			typename CoordT,
			typename T
		>
		class hpcg_builder {

			using system_t = grb::utils::geometry::linearized_halo_ndim_system< CoordT, DIMS >;

			system_t system;
			// const grb::utils::geometry::linearized_halo_ndim_system< CoordT, DIMS > system;
			const CoordT halo;

		public:

			using hpcg_sys_iterator = matrix_generator_iterator< DIMS, CoordT, T >;

			hpcg_builder(
				const std::array< CoordT, DIMS > &sizes,
				CoordT _halo
			) :
				system( sizes, _halo ),
				halo( _halo )
			{
				if( _halo <= 0 ) {
					throw std::invalid_argument( "halo should be higher than 0" );
				}
				for( const auto i : sizes ) {
					if( i < 2 * _halo + 1 ) {
						throw std::invalid_argument( "Iteration halo goes beyond system sizes" );
					}
				}
			}

			hpcg_builder( const hpcg_builder< DIMS, CoordT, T> & ) = delete;

			hpcg_builder( hpcg_builder< DIMS, CoordT, T> && ) = delete;

			hpcg_builder< DIMS, CoordT, T> & operator=( const hpcg_builder< DIMS, CoordT, T> & ) = delete;

			hpcg_builder< DIMS, CoordT, T> & operator=( hpcg_builder< DIMS, CoordT, T> && ) = delete;

			size_t system_size() const {
				return system.halo_system_size();
			}

			hpcg_sys_iterator make_begin_iterator(
				T diag,
				T non_diag
			) {
				return hpcg_sys_iterator( system, diag, non_diag );
			}

			hpcg_sys_iterator make_end_iterator(
				T diag,
				T non_diag
			) {
				hpcg_sys_iterator result( system, diag, non_diag );
				result += system_size() - 1; // do not trigger boundary checks
				++result;
				return result;
			}

		};






























		template<
			size_t DIMS,
			typename CoordT,
			typename T
		>
		class hpcg_coarsener_builder;


		/**
		 * @brief Class to generate the coarsening matrix of an underlying \p DIMS -dimensional system.
		 *
		 * This class coarsens a finer system to a coarser system by projecting each input value (column),
		 * espressed in finer coordinates, to an output (row) value espressed in coarser coordinates.
		 * The coarser sizes are assumed to be row_generator#physical_sizes, while the finer sizes are here
		 * stored inside #finer_sizes.
		 *
		 * The corresponding refinement matrix is obtained by transposing the coarsening matrix.
		 *
		 * @tparam DIMS number of dimensions of the system
		 * @tparam T type of matrix values
		 */
		template<
			size_t DIMS,
			typename CoordT,
			typename T
		>
		struct coarsener_generator_iterator {

			friend hpcg_coarsener_builder< DIMS, CoordT, T >;

			using RowIndexType = CoordT; ///< numeric type of rows
			using ColumnIndexType = CoordT;
			using ValueType = T;

			using lin_system_t = grb::utils::geometry::linearized_ndim_system< CoordT,
				grb::utils::geometry::array_vector_storage< CoordT, DIMS > >;
			using __iter_t = typename lin_system_t::iterator;
			using self_t = coarsener_generator_iterator< DIMS, CoordT, T >;
			using array_t = std::array< CoordT, DIMS >;

			struct __value {

				friend self_t;

				__value(
					RowIndexType i,
					ColumnIndexType j
				) noexcept :
					_i( i ),
					_j( j )
				{}

				__value( const __value & ) = default;

				__value & operator=( const __value & ) = default;

				inline RowIndexType i() const { return _i; }
				inline ColumnIndexType j() const { return _j; }
				inline ValueType v() const {
					return static_cast< ValueType >( 1 );
				}

			private:
				RowIndexType _i;
				ColumnIndexType _j;
			};

			// interface for std::random_access_iterator
			using iterator_category = std::random_access_iterator_tag;
			using value_type = __value;
			using pointer = const value_type;
			using reference = const value_type&;
			using difference_type = typename __iter_t::difference_type;

			coarsener_generator_iterator( const self_t & o ) = default;

			coarsener_generator_iterator( self_t && o ) = default;

			self_t & operator=( const self_t & ) = default;

			self_t & operator=( self_t && ) = default;

			/**
			 * @brief Increments the row and the column according to the respective physical sizes,
			 * thus iterating onto the coarsening matrix coordinates.
			 *
			 * @return \code *this \endcode, i.e. the same object with the updates row and column
			 */
			self_t & operator++() noexcept {
				(void) ++_sys_iter;
				update_coords();
				return *this;
			}

			self_t & operator+=( size_t offset ) {
				_sys_iter += offset;
				update_coords();
				return *this;
			}

			difference_type operator-( const self_t &o ) const {
				return this->_sys_iter - o._sys_iter;
			}

			/**
			 * @brief Returns whether \c this and \p o differ.
			 */
			bool operator!=( const self_t &o ) const {
				return this->_sys_iter != o._sys_iter;
			}

			/**
			 * @brief Returns whether \c this and \p o are equal.
			 */
			bool operator==( const self_t &o ) const {
				return ! this->operator!=( o );
			}

			/**
			 * @brief Operator returning the triple to directly access row, column and element values.
			 *
			 * Useful when building the matrix by copying the triple of coordinates and value,
			 * like for the BSP1D backend.
			 */
			reference operator*() const {
				return _val;
			}

			pointer operator->() const {
				return &_val;
			}

			/**
			 * @brief Returns the current row, according to the coarser system.
			 */
			inline RowIndexType i() const {
				return _val.i();
			}

			/**
			 * @brief Returns the current column, according to the finer system.
			 */
			inline ColumnIndexType j() const {
				return _val.j();
			}

			/**
			 * @brief Returns always 1, as the coarsening keeps the same value.
			 */
			inline ValueType v() const {
				return _val.v();
			}

		private:
			//// incremented when incrementing the row coordinates; is is the ration between
			//// #finer_sizes and row_generator#physical_sizes
			const lin_system_t *_lin_sys;
			const array_t *_steps; ///< array of steps, i.e. how much each column coordinate (finer system) must be
			__iter_t _sys_iter;
			value_type _val;

			/**
			 * @brief Construct a new \c coarsener_generator_iterator object from the coarser and finer sizes,
			 * setting its row at \p _current_row and the column at the corresponding value.
			 *
			 * Each finer size <b>must be an exact multiple of the corresponding coarser size</b>, otherwise the
			 * construction will throw an exception.
			 *
			 * @param _coarser_sizes sizes of the coarser system (rows)
			 * @param _finer_sizes sizes of the finer system (columns)
			 * @param _current_row row (in the coarser system) to set the iterator on
			 */
			coarsener_generator_iterator(
				const lin_system_t &system,
				const array_t &steps
			) noexcept :
				_lin_sys( &system ),
				_steps( &steps ),
				_sys_iter( _lin_sys->begin() ),
				_val(0, 0)
			{
				update_coords();
			}

			void update_coords() noexcept {
				_val._i = _sys_iter->get_linear_position();
				_val._j = coarse_rows_to_finer_col();
			}

			/**
			 * @brief Returns the row coordinates converted to the finer system, to compute
			 * the column value.
			 */
			ColumnIndexType coarse_rows_to_finer_col() const noexcept {
				ColumnIndexType finer { 0 };
				ColumnIndexType s { 1 };
				for( size_t i { 0 }; i < DIMS; i++ ) {
					s *= (*_steps)[ i ];
					finer += s * _sys_iter->get_position()[ i ];
					s *= _lin_sys->get_sizes()[ i ];
				}
				return finer;
			}
		};


		template<
			size_t DIMS,
			typename CoordT,
			typename T
		>
		class hpcg_coarsener_builder {
		public:

			using array_t = std::array< CoordT, DIMS >;
			using hpcg_coarsener_iterator = coarsener_generator_iterator< DIMS, CoordT, T >;

			hpcg_coarsener_builder(
				const array_t &_coarser_sizes,
				const array_t &_finer_sizes
			) : system( _coarser_sizes.begin(), _coarser_sizes.end() ) {
				for( size_t i { 0 }; i < DIMS; i++ ) {
					// finer size MUST be an exact multiple of coarser_size
					size_t step { _finer_sizes[ i ] / _coarser_sizes[ i ] };
					if( step == 0 || _finer_sizes[ i ] / step != _coarser_sizes[ i ] ) {
						throw std::invalid_argument(
							std::string( "finer size of dimension " ) + std::to_string( i ) +
							std::string( "is not an exact multiple of coarser size" )
						);
					}
					steps[ i ] = step;
				}
			}

			hpcg_coarsener_builder( const hpcg_coarsener_builder< DIMS, CoordT, T> & ) = delete;

			hpcg_coarsener_builder( hpcg_coarsener_builder< DIMS, CoordT, T> && ) = delete;

			hpcg_coarsener_builder< DIMS, CoordT, T> & operator=( const hpcg_coarsener_builder< DIMS, CoordT, T> & ) = delete;

			hpcg_coarsener_builder< DIMS, CoordT, T> & operator=( hpcg_coarsener_builder< DIMS, CoordT, T> && ) = delete;

			size_t system_size() const {
				return system.system_size();
			}

			hpcg_coarsener_iterator make_begin_iterator() {
				return hpcg_coarsener_iterator( system, steps );
			}

			hpcg_coarsener_iterator make_end_iterator() {
				hpcg_coarsener_iterator result( system, steps );
				result += system_size() - 1; // do not trigger boundary checks
				++result;
				return result;
			}

		private:
			const grb::utils::geometry::linearized_ndim_system< CoordT,
				grb::utils::geometry::array_vector_storage< CoordT, DIMS > > system;

			array_t steps; ///< array of steps, i.e. how much each column coordinate (finer system) must be
			//// incremented when incrementing the row coordinates; is is the ration between
			//// #finer_sizes and row_generator#physical_sizes
		};


	} // namespace algorithms
} // namespace grb

#endif // _H_GRB_ALGORITHMS_NDIM_MATRIX_BUILDERS

