
/*
 *   Copyright 2021 Huawei Technologies Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file system_builders.hpp
 * @author Alberto Scolari (alberto.scolari@huawei.com)
 * @brief Utilities to build matrices for an HPCG simulation in a generic number of dimensions
 *
 * In particular, the main matrices are:
 * - a system matrix, generated from an N-dimenional space of coordinates by iterating along
 *   each dimension in priority order, where the first dimension has highest priority and the last
 *   dimension least priority; for each point (row), all its N-dimensional neighbours within
 *   a given distance are generated for the column
 * - a coarsening matrix, generated by iterating on a coarser system of N dimensions (row) and projecting
 *   each point to a corresponding system of finer sizes
 *
 * @date 2021-04-30
 */

#ifndef _H_GRB_ALGORITHMS_HPCG_SYSTEM_BUILDER
#define _H_GRB_ALGORITHMS_HPCG_SYSTEM_BUILDER

#include <algorithm>
#include <array>
#include <cstddef>
#include <initializer_list>
#include <numeric>
#include <stdexcept>
#include <string>
#include <type_traits>
#include <utility>
#include <vector>
#include <cstddef>
#include <iterator>

#include <graphblas/utils/multigrid/halo_matrix_generator_iterator.hpp>

namespace grb {
	namespace algorithms {

		template<
			size_t DIMS,
			typename CoordType,
			typename ValueType
		> class HPCGSystemBuilder {
		public:
			struct HPCGDiagGenerator {

				HPCGDiagGenerator(
					ValueType diag,
					ValueType non_diag
				) noexcept :
					_diag( diag ),
					_non_diag( non_diag ) {}

				HPCGDiagGenerator & operator=( const HPCGDiagGenerator & ) = default;

				inline ValueType operator()( const CoordType &i, const CoordType &j ) const noexcept {
					return j == i ? _diag: _non_diag;
				}

				ValueType _diag;
				ValueType _non_diag;
			};

			using HaloSystemType = grb::utils::multigrid::LinearizedHaloNDimSystem< DIMS, CoordType >;
			using Iterator = grb::utils::multigrid::HaloMatrixGeneratorIterator< DIMS, CoordType,
				ValueType, HPCGDiagGenerator >;

			HPCGSystemBuilder(
				const std::array< CoordType, DIMS > &sizes,
				CoordType halo,
				ValueType diag,
				ValueType non_diag
			) :
				_system( sizes, halo ),
				_diag_generator( diag, non_diag )
			{
				if( halo <= 0 ) {
					throw std::invalid_argument( "halo should be higher than 0" );
				}
				for( const auto i : sizes ) {
					if( i < 2 * halo + 1 ) {
						throw std::invalid_argument( "Iteration halo goes beyond system sizes" );
					}
				}
			}

			HPCGSystemBuilder( const HPCGSystemBuilder< DIMS, CoordType, ValueType > & ) = default;

			HPCGSystemBuilder( HPCGSystemBuilder< DIMS, CoordType, ValueType > && ) = default;

			HPCGSystemBuilder< DIMS, CoordType, ValueType > & operator=( const HPCGSystemBuilder< DIMS, CoordType, ValueType > & ) = default;

			HPCGSystemBuilder< DIMS, CoordType, ValueType > & operator=( HPCGSystemBuilder< DIMS, CoordType, ValueType > && ) = default;

			size_t system_size() const {
				return _system.base_system_size();
			}

			size_t num_neighbors() const {
				return _system.halo_system_size();
			}

			const HaloSystemType & get_generator() const {
				return _system;
			}

			Iterator make_begin_iterator() const {
				return Iterator( _system, _diag_generator );
			}

			Iterator make_end_iterator() const {
				Iterator result( _system, _diag_generator );
				result += num_neighbors() - 1; // do not trigger boundary checks
				++result;
				return result;
			}

			ValueType get_diag_value() const {
				return _diag_generator._diag;
			}

			ValueType get_non_diag_value() const {
				return _diag_generator._non_diag;
			}


		private:
			HaloSystemType _system;
			HPCGDiagGenerator _diag_generator;
		};

	} // namespace algorithms
} // namespace grb

#endif // _H_GRB_ALGORITHMS_HPCG_SYSTEM_BUILDER

