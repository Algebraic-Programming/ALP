
/*
 *   Copyright 2021 Huawei Technologies Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file argument_parser.cpp
 * @author Alberto Scolari (alberto.scolari@huawei.com)
 * @brief Implementation of the argument parser from internal_argument_parser.hpp.
 *
 * Implementation of the argument parser, where most of the methods to add arguments are
 * pre-processor-generated by including the parsed_types.hpp file and by re-defininf the
 * macro listing each parsed type. The same occurs for most of the lambdas required to
 * generate the parsing information.
 *
 * @date 2021-04-30
 */

#include <cmath>
#include <cstdlib>
#include <ios>
#include <iostream>
#include <stdexcept>
#include <utility>

#include <errno.h>

// do NOT change this include order!!!
#include "internal_argument_parser.hpp"
#include "internal_argument_parser_defs.hpp"


argument_parse_info::argument_parse_info( void * _target,
	parser_t & _parser,
	bool option,
	default_value_container def,
	def_setter_t & _default_setter,
	def_printer_t & _default_printer,
	const char * desc ) :
	target( _target ),
	parser( _parser ), is_option( option ), default_value( def ), default_setter( _default_setter ), default_printer( _default_printer ), description( desc ) {}

//============================================================

argument_parser::argument_parser() {
	help_parser = [ this ]( const char *, void * ) -> void {
		this->print_all_arguments();
		std::exit( -1 );
	};
	__add_argument_unsafe< bool >( "-h", help_target, help_parser, true, false, nothing_setter, nothing_printer, "print this description", false );
}

//================ PREPROCESSOR-GENERATED MEMBERS ==================

// parsers are custom and no bool parser exists
#define DEFINE_PARSER( _t ) argument_parser::parser_t const argument_parser::PARSER_NAME( _t )

DEFINE_PARSER( size_parse_t ) = []( const char * arg, void * tgt ) -> void {
	size_t * ptr = static_cast< size_t * >( tgt );
	errno = 0;
	char * end = NULL;
	size_t res = strtoul( arg, &end, 10 );
	if( errno != 0 ) {
		throw std::invalid_argument( std::string( "Could not parse numerical argument " ) + arg );
	}
	*ptr = res;
};

DEFINE_PARSER( str_parse_t ) = []( const char * arg, void * tgt ) -> void {
	const char ** ptr = static_cast< str_parse_t * >( tgt );
	*ptr = arg;
};

DEFINE_PARSER( double_parse_t ) = []( const char * arg, void * tgt ) -> void {
	double * ptr = static_cast< double * >( tgt );
	errno = 0;
	char * end = NULL;
	double res = strtod( arg, &end );
	if( res == HUGE_VAL ) {
		throw std::invalid_argument( std::string( "Argument value out of range: " ) + arg );
	}
	if( res == 0.0 && end == arg ) {
		throw std::invalid_argument( std::string( "Could not parse argument value " ) + arg );
	}
	*ptr = res;
};

// all default setters are equal
#define PARSED_TYPE( _t, _vdef )                                                                                                                       \
	argument_parser::def_setter_t const argument_parser::DEF_SET_NAME( _t ) = []( const argument_parser::def_container_t & def, void * tgt ) -> void { \
		*static_cast< _t * >( tgt ) = def.DEF_CONT_MEMBER_NAME( _t );                                                                                  \
	};
#include "parsed_types.hpp"
#undef PARSED_TYPE

// default printers are equal, except for bool
#define DEFINE_DEF_PRINT( _t ) argument_parser::def_printer_t const argument_parser::DEF_PRINT_NAME( _t )

#define NO_BOOL
#define PARSED_TYPE( _t, _vdef )                                                                              \
	DEFINE_DEF_PRINT( _t ) = []( const argument_parser::def_container_t & def, std::ostream & str ) -> void { \
		str << def.DEF_CONT_MEMBER_NAME( _t );                                                                \
	};
#include "parsed_types.hpp"
#undef PARSED_TYPE
#undef NO_BOOL

DEFINE_DEF_PRINT( bool_parse_t ) = []( const argument_parser::def_container_t & def, std::ostream & str ) -> void {
	str << std::boolalpha;
	str << def.DEF_CONT_MEMBER_NAME( bool_parse_t );
	str << std::noboolalpha;
};

// define methods for mandatory and optional arguments
#define NO_BOOL
#define PARSED_TYPE( _t, _vdef )                                                                                                            \
	argument_parser & argument_parser::MANDATORY_SIGNATURE( _t, arg, target, descr ) {                                                      \
		return __add_argument< _t >( arg, target, PARSER_NAME( _t ), false, _vdef, DEF_SET_NAME( _t ), DEF_PRINT_NAME( _t ), descr, true ); \
	}                                                                                                                                       \
	argument_parser & argument_parser::OPTIONAL_SIGNATURE( _t, arg, target, def, descr ) {                                                  \
		return __add_argument< _t >( arg, target, PARSER_NAME( _t ), false, def, DEF_SET_NAME( _t ), DEF_PRINT_NAME( _t ), descr, false );  \
	}
#include "parsed_types.hpp"
#undef PARSED_TYPE
#undef NO_BOOL

//===================== CUSTOM MEMBERS ========================

argument_parser::parser_t const argument_parser::option_parser = []( const char * arg, void * tgt ) -> void {
	bool * ptr = static_cast< bool * >( tgt );
	// arg here is interpreted as pointer to the default value
	const bool * def = reinterpret_cast< const bool * >( arg );
	*ptr = ! ( *def );
};

argument_parser::def_setter_t const argument_parser::nothing_setter = []( const argument_parser::def_container_t & def, void * tgt ) -> void {
	(void)def;
	(void)tgt;
};

argument_parser::def_printer_t const argument_parser::nothing_printer = []( const argument_parser::def_container_t & def, std::ostream & str ) -> void {
	(void)def;
	(void)str;
};

void argument_parser::print_argument( const char * arg, const argument_parse_info & p, bool mandatory ) {
	if( ! mandatory ) {
		std::cout << "[optional]  ";
	}
	std::cout << arg;
	if( p.description != nullptr ) {
		std::cout << " : " << p.description;
	}
	std::cout << std::endl;
	if( ! p.is_option ) {
		std::cout << "\t\t\t"
				  << "DEFAULT VALUE: ";
		p.default_printer( p.default_value, std::cout );
		std::cout << std::endl;
	}
	std::cout << std::endl;
}

void argument_parser::print_all_arguments() {
	std::cout << "ARGUMENTS:" << std::endl << std::endl;
	mandatory_set::const_iterator cend { mandatory_args.cend() };
	argument_parser::print_argument( args[ 0 ], parsers[ 0 ], false );
	for( size_t i = 1; i < parsers.size(); ++i ) {
		argument_parser::print_argument( args[ i ], parsers[ i ], mandatory_args.find( i ) != cend );
	}
}

argument_parser & argument_parser::add_option( const char * arg, bool & target, bool def, const char * desc ) {
	return __add_argument( arg, target, option_parser, true, def, DEF_SET_NAME( bool_parse_t ), DEF_PRINT_NAME( bool_parse_t ), desc, false );
}

//===================== PARSING METHODS ========================

void argument_parser::parse( int argc, const char * const * argv ) {

	// register all arguments as not met
	const bool not_found = false;
	found.assign( parsers.size(), not_found );

	arg_map::const_iterator args_end { args_info.cend() };
	mandatory_set::const_iterator mandatory_end { mandatory_args.cend() };

	const size_t num_args { static_cast< size_t >( argc ) };
	size_t i = 1;
	while( i < num_args ) {
		const char * const arg { argv[ i ] };
		const std::string str_arg( arg );
		arg_map::const_iterator pos { args_info.find( str_arg ) };
		if( pos == args_end ) {
			std::cerr << "Unknown argument " << arg << std::endl;
			print_all_arguments();
			std::exit( -1 );
		}
		size_t position { pos->second };
		if( found[ position ] ) {
			std::cerr << "Argument \"" << arg << "\" specified twice" << std::endl;
			std::exit( -1 );
		}
		argument_parse_info & info { parsers[ position ] };
		bool is_mandatory { mandatory_args.find( i ) != mandatory_end };
		const char * argument_value;
		if( info.is_option ) {
			argument_value = reinterpret_cast< const char * >( &info.default_value.bool_parse_t_value );
		} else {
			if( i + 1 == num_args ) {
				// no more arguments: error
				std::cerr << "No value for argument \"" << arg << "\"" << std::endl;
				print_argument( arg, info, is_mandatory );
				std::exit( -1 );
			}
			const std::string value( argv[ i + 1 ] );
			arg_map::const_iterator argument_match { args_info.find( value ) };
			if( argument_match != args_end ) {
				// argument value is an option: wrong or ambiguous
				std::cerr << "No value for argument \"" << arg << "\" in position " << i + 1 << std::endl;
				print_argument( arg, info, is_mandatory );
				std::exit( -1 );
			}
			argument_value = argv[ ++i ];
		}
		// attempt parsing
		try {
			info.parser( argument_value, info.target );
		} catch( const std::invalid_argument & e ) {
			std::cerr << "ERROR when parsing argument " << arg << ":" << std::endl << "\t" << e.what() << std::endl;
			print_argument( arg, info, is_mandatory );
			std::exit( -1 );
		}
		// parsing successful: register as completed
		found[ position ] = true;
		i++;
	}

	// then assign remaining arguments as default and check for mandatory arguments not passed
	for( size_t i = 1; i < found.size(); i++ ) {
		if( ! found[ i ] ) {
			argument_parse_info & info { parsers[ i ] };
			if( mandatory_args.find( i ) != mandatory_end ) {
				const char * const arg { argv[ i ] };
				std::cerr << "ERROR argument \"" << arg << "\" is mandatory but not present" << std::endl;
				print_argument( arg, info, true );
				std::exit( -1 );
			}
			info.default_setter( info.default_value, info.target );
		}
	}
	// reset everything for another call
	found.clear();
}

