
/*
 *   Copyright 2021 Huawei Technologies Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#ifndef _H_GRB_ALGORITHMS_HPCG_COLORING
#define _H_GRB_ALGORITHMS_HPCG_COLORING

#include <vector>
#include <cstddef>

#include <graphblas/utils/geometry/linearized_halo_ndim_system.hpp>

namespace grb {
	namespace algorithms {


		/**
		 * Coloring algorithm for matrix generated by a \p DIMS - dimensional system.
		 *
		 * This function implements a < b>greedy heuristics< /b> to color the rows of a matrix generated by
		 * a \p DIMS - dimensional generator \p system, so that no two connected elements < em>(i,j)< /em>
		 * in the system (corresponding to a nonzero < em>(i,j)< /em> entry in the matrix) have the same color.
		 * If \p reorder_rows_per_color is false (as per default), the coloring information is stored into
		 * \p row_colors, while \p color_counters stores the number of rows for each color.
		 *
		 * If \p reorder_rows_per_color is true, the function performs the additional step of \b re-ordering
		 * the rows depending on their color: rows of color \a 0 are moved first, then rows of color \a 1
		 * are moved to the following positions and so on. In this case, \p row_colors stores the new row number
		 * while \p color_counters stores at each position \a i the new position of the first row of color \a i.
		 *
		 * In both cases, \a color_counters.size() gives the number of found colors.
		 *
		 * @tparam DIMS dimensions of the system
		 * @tparam CoordType type of the coordinates
		 * @param[in] system generator for an \p DIMS - dimesional system with halo
		 * @param[out] row_colors if \p reorder_rows_per_color is false, stores the color of each row;
		 * 	if \p reorder_rows_per_color is true, stores the new position of each row, so that rows
		 * 	of the same color are gourped together; the initial content of the vector is destroyed
		 * @param[out] color_counters if \p reorder_rows_per_color is false, stores the number of rows per color;
		 * 	if \p reorder_rows_per_color is true, stores at each position \a i the offset in \p color_counters
		 * 	where the (clustered) rows of color \a i start from; the initial content of the vector is destroyed
		 * @param[in] reorder_rows_per_color whether to do the clustering after the coloring
		 */
		template<
			std::size_t DIMS,
			typename CoordType
		> void color_matrix_greedy(
			const grb::utils::geometry::linearized_halo_ndim_system< CoordType, DIMS > &system,
			std::vector< CoordType > &row_colors,
			std::vector< CoordType > &color_counters,
			bool reorder_rows_per_color = false
		) {

			// This function can be used to completely transform any part of the data structures.
			// Right now it does nothing, so compiling with a check for unused variables results in complaints

			CoordType nrows = system.system_size();
			row_colors.insert( row_colors.begin(), nrows, nrows ); // value `nrow' means `uninitialized'; initialized colors go from 0 to nrow-1
			CoordType totalColors = 1;
			row_colors[0] = 0; // first point gets color 0

			// Finds colors in a greedy (a likely non-optimal) fashion.
			typename grb::utils::geometry::linearized_halo_ndim_system< CoordType, DIMS >::iterator begin = system.begin();
			begin.next_element(); // skip first row

			while( begin.has_more_elements() ) {
				CoordType curRow = begin->get_element_linear();

				if( row_colors[ curRow ] != nrows ) {
					// if color already assigned to curRow
					continue;
				}
				std::vector< bool > assigned( totalColors, false );
				CoordType currentlyAssigned = 0;

				while( begin.has_more_neighbours() ) {
					CoordType curCol = begin->get_neighbor_linear();
					if( curCol < curRow ) {
						assert( row_colors[ curCol ] < nrows ); // if curCol < curRow, curCol has already a color assigned
						std::vector< bool >::reference color_is_assigned = assigned[ row_colors[ curCol ] ];
						if( !color_is_assigned ) {
							// count how many colors are already assigned
							(void) currentlyAssigned++;
						}
						// track which colors are assigned
						color_is_assigned = true;
					} // else // could take advantage of indices being sorted
					begin.next_neighbour();
				}

				if( currentlyAssigned < totalColors ) {
					// if there is at least one color left to use, look for it
					for( CoordType j = 0; j < totalColors; ++j ) {
						if( !assigned[ j ] ) {
							// if no neighbor with this color, use it for this row
							row_colors[ curRow ] = j;
							break;
						}
					}
				} else {
					assert( row_colors[ curRow ] == nrows );
					if( row_colors[ curRow ] == nrows ) {
						row_colors[ curRow ] = totalColors;
						(void) totalColors++;
					} else {
						assert( 0 ); // should never get here
					}
				}
				begin.next_element();
			}

#ifdef _DEBUG
			std::cout << "assigned colors: " << totalColors << " [ <row> -> <color>]\n";
			for( size_t i = 0; i < row_colors.size(); i++ ){
				std::cout << i << " -> " << row_colors[ i ] << ", ";
			}
			std::cout << std::endl;
#endif

			// count number of vertices per color
			color_counters.insert( color_counters.begin(), totalColors, 0 );
			for( CoordType i = 0; i < nrows; ++i ) {
				(void) color_counters[ row_colors[ i ] ]++;
			}

			if( !reorder_rows_per_color ) {
				return;
			}

			// form in-place prefix scan
			CoordType old = 0, old0;
			for( CoordType i = 1; i < totalColors; ++i ) {
				old0 = color_counters[i];
				color_counters[i] = color_counters[i-1] + old;
				old = old0;
			}
			color_counters[0] = 0;

			// translate `colors' into a permutation
			for( CoordType i = 0; i < nrows; ++i ) {
				row_colors[ i ] = color_counters[ row_colors[ i ] ]++;
			}
		}

	} // namespace algorithms
} // namespace grb



#endif // _H_GRB_ALGORITHMS_HPCG_COLORING

